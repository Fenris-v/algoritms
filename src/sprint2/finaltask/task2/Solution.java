package sprint2.finaltask.task2;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Stack;
import java.util.StringTokenizer;

// Задание связано с обратной польской нотацией. Она используется для парсинга арифметических выражений. Еще её
// иногда называют постфиксной нотацией.
// В постфиксной нотации операнды расположены перед знаками операций.
//
// Пример 1:
// 3 4 +
// означает 3 + 4 и равно 7
//
// Пример 2:
// 12 5 /
// Так как деление целочисленное, то в результате получим 2.
//
// Пример 3:
// 10 2 4 * -
// означает 10 - 2 * 4 и равно 2
//
// Разберём последний пример подробнее:
// Знак * стоит сразу после чисел 2 и 4, значит к ним нужно применить операцию, которую этот знак обозначает, то есть
// перемножить эти два числа. В результате получим 8.
// После этого выражение приобретёт вид:
// 10 8 -
// Операцию «минус» нужно применить к двум идущим перед ней числам, то есть 10 и 8. В итоге получаем 2.
// Рассмотрим алгоритм более подробно. Для его реализации будем использовать стек.
// Для вычисления значения выражения, записанного в обратной польской нотации, нужно считывать выражение слева
// направо и придерживаться следующих шагов:
// Обработка входного символа:
// Если на вход подан операнд, он помещается на вершину стека.
// Если на вход подан знак операции, то эта операция выполняется над требуемым количеством значений, взятых из стека
// в порядке добавления. Результат выполненной операции помещается на вершину стека.
// Если входной набор символов обработан не полностью, перейти к шагу 1.
// После полной обработки входного набора символов результат вычисления выражения находится в вершине стека. Если в
// стеке осталось несколько чисел, то надо вывести только верхний элемент.
// Замечание про отрицательные числа и деление: в этой задаче под делением понимается математическое целочисленное
// деление. Это значит, что округление всегда происходит вниз. А именно: если a / b = c, то b ⋅ c — это наибольшее
// число, которое не превосходит a и одновременно делится без остатка на b.
// Например, -1 / 3 = -1. Будьте осторожны: в C++, Java и Go, например, деление чисел работает иначе.
// В текущей задаче гарантируется, что деления на отрицательное число нет.
//
// Формат ввода
// В единственной строке дано выражение, записанное в обратной польской нотации. Числа и арифметические операции
// записаны через пробел.
// На вход могут подаваться операции: +, -, *, / и числа, по модулю не превосходящие 10000.
// Гарантируется, что значение промежуточных выражений в тестовых данных по модулю не больше 50000.
//
// Формат вывода
// Выведите единственное число — значение выражения.
/*
-- ПРИНЦИП РАБОТЫ --
В качестве стека было принято решение использовать ArrayList, чтобы не нужно было следить за размером стека
самостоятельно. Возможно здесь это лишняя трата памяти и оверинжиниринг, но зато упрощает жизнь. При чтении строки
(токенов) вызывается метод Calculator.execute(String s). Этот метод при помощи регулярного выражения определяет,
является ли переданная строка числом и в зависимости от этого либо добавляет число после конвертации в стек, либо
выполняет математическую операцию.

При выполнении математической операции берутся 2 последних числа из стека, выполняется математическая операция, а
затем последний элемент стека удаляется, а предпоследний заменяется новым значением.

После окончания парсинга строки, вызывается метод Calculator.getResult(), который возвращает последнее число из стека.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Временная сложность линейно зависит от количества переданных аргументов. Получается, время выполнения алгоритма O(n).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Если учитывать, что на вход обязательно принимается валидная строка (польская нотация) затраты по памяти будут
O(n/2 + 1), соответственно, опуская константы остаётся O(n).
 */
public class Solution {
    public static void main(String[] args) {
        try (
                BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out))
        ) {
            StringTokenizer stringTokenizer = new StringTokenizer(reader.readLine());
            Calculator calculator = new Calculator();
            while (stringTokenizer.hasMoreTokens()) {
                calculator.execute(stringTokenizer.nextToken());
            }

            writer.write(String.valueOf(calculator.getResult()));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}

class Calculator {
    private final Stack<Integer> stack = new Stack<>();

    public int getResult() {
        return stack.get(stack.size() - 1);
    }

    public void execute(String str) {
        switch (str) {
            case "+":
                plus();
                break;
            case "-":
                minus();
                break;
            case "/":
                divide();
                break;
            case "*":
                multiply();
                break;
            default:
                stack.push(Integer.parseInt(str));
        }
    }

    private void plus() {
        stack.push(stack.pop() + stack.pop());
    }

    private void minus() {
        int value = stack.pop();
        stack.push(stack.pop() - value);
    }

    private void multiply() {
        stack.push(stack.pop() * stack.pop());
    }

    private void divide() {
        int value = stack.pop();
        stack.push(Math.floorDiv(stack.pop(), value));
    }
}
